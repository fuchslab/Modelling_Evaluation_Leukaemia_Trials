################################################################################
# Function to simulate one data set analogous to knockout experiments with 
# package GillespieSSA: one mouse yields one input and one output value

gillespie_sim_ko_exp <- function(
    theta, x0, sigma, smat, props, design){
  
  # Empty data frame for simulation results per mouse and time point: 
  # values for x1, x2 and the observable, here called "value"
  data <- as.data.frame(matrix(NA, nrow = 0, ncol = 5))
  column_names <- c("mouse", "time", "x1", "x2", "value")
  colnames(data) <- column_names
  
  # Simulation of one Gillespie trajectory for each PDX model individually
  # Counter for simulated PDX model
  pdx_counter <- 1
  for(d in 1:nrow(design)){
    for (t in 1:design[d, "num_pdx"]) {
      
      # Simulate one trajectory with Gillespie's algorithm
      out <- ssa(
        x0 = x0,
        a = props,
        nu = smat,
        parms = theta,
        tf = design[d, "output_day"],
        method = ssa.otl(), 
        consoleInterval = 1
      )
      out_data <- out$data
      
      # Extract data for input time time 0 and output time
      out_data <- rbind(vector('numeric', length = length(x0) + 1), out_data)
      out_obs <- get_obs_times(
        out_data, time = as.numeric(design[d, c("input_day", "output_day")]))
      
      # Obtain simulated observable by linear transformation
      obs <- out_obs[,2]/(out_obs[,2] + out_obs[,3])
      
      # Add simulations to data frame
      df <- data.frame(rep(pdx_counter, length(obs)), out_obs[, 1], out_obs[, 2], 
                       out_obs[, 3], obs)
      data <- rbind(data, setNames(df, nm = column_names))
      
      # Increase PDX counter by 1
      pdx_counter <- pdx_counter + 1
    }
  }
  
  # Multiply simulated value for observable with log-normally distributed error
  data[,"value"] <- data[,"value"] * rlnorm(
    n = nrow(data), meanlog = (-(sigma^2)/2), sdlog = sigma)

  # Order data
  data <- data[order(data$time, data$mouse),]
  
  return(data)
}


################################################################################
# Function to extract values from Gillespie trajectory for specified time points

get_obs_times <- function(xmat, time){
  numCol <- ncol(xmat)
  indizes <- sapply(time, function(x) max(which(xmat[, 1] <= x)))
  res_mat <- matrix(NA, ncol = numCol, nrow = length(indizes))
  res_mat[, 2:numCol] <- xmat[indizes, 2:numCol]
  res_mat[, 1] <- time
  return(res_mat)
}


################################################################################
# Function to extract computed CIs from data frame generated by function 
# confint() and creates a list out of it. If a profile likelihood crosses the 
# confidence threshold more than twice, the CI is manually computed using 
#interpolation

ci_extraction <- function(ci, profiles, obj_value, conf_level){
  
  # Define function to calculate difference of x and y values
  diff_function <- function(x_interval, y_interval, x_val) {
    y_val <- approx(x_interval, y_interval, xout = x_val)$y
    return(y_val - threshold)
  }
  
  # If one of the boundaries of the CI provided by confint() is NA (profile 
  # likelihood crosses confidence threshold more than twice), re-compute boundaries
  if (any(is.na(ci[, c("lower", "upper")]))){
    
    # Filter parameters for which CI must be computed manually and remove them from 
    # results of confint()
    ci_na <- ci[is.na(ci$lower) | is.na(ci$upper),]
    
    # Confidence threshold
    threshold <- qchisq(p = conf_level, df = 1) + obj_value
    
    # Empty data frame in which parts of manually computed intervals are collected
    confidence_intervals_df <- data.frame(
      name = character(0), value = numeric(0), lower = numeric(0), upper = numeric(0))
    
    # Loop through set of parameters for which CI needs to be re-computed
    for (j in 1:nrow(ci_na)){
      
      # Extract parameter name
      par_name <<- ci_na[j, "name"]
      
      # Extract data for profile likelihood: data for x-axis and y-axis
      x_profile <- subset(profiles, whichPar == par_name)[[par_name]]
      y_profile <- subset(profiles, whichPar == par_name)[["data"]]
      
      # Evaluate differences between y values of the profile likelihood and
      # confidence threshold 
      differences <- y_profile - threshold
      
      # Identify sign changes of these difference indicating a crossing of the
      # confidence threshold
      sign_changes <- which(diff(sign(differences)) != 0)
      crossing_points <- sort(x_profile[sign_changes])
      
      # Create intervals between changes of sign
      for (c in seq_along(crossing_points)) {
        
        # Region before first crossing point with interval (-∞, c1]
        if (c == 1 && differences[sign_changes[c]] < 0) {
          
          # Interpolate crossing point of indicated crossing between two 
          # consecutive x-values of profile likelihoods
          x_interval <- c(x_profile[sign_changes[c]], x_profile[sign_changes[c] + 1])
          y_interval <- c(y_profile[sign_changes[c]], y_profile[sign_changes[c] + 1])
          x_val <- seq(x_interval[1], x_interval[2], length.out = 100)
          diff_interpol <- diff_function(x_interval, y_interval, x_val)
          sign_change <- which(diff(sign(diff_interpol)) != 0)
          
          # Add region to data frame
          confidence_intervals_df <- rbind(
            confidence_intervals_df, data.frame(
              name = par_name, 
              value = ci_na[j, "value"],
              lower = -Inf,
              upper = x_val[sign_change + 1]))
          
        # Region between crossing points with interval [c_(i), c_(i+1)]
        } else if ((c != length(crossing_points)) && 
                   (differences[sign_changes[c]] > 0) && 
                   (differences[sign_changes[c + 1]] < 0)) {
          
          # Interpolate lower boundary 
          x_interval <- c(x_profile[sign_changes[c]], x_profile[sign_changes[c] + 1])
          y_interval <- c(y_profile[sign_changes[c]], y_profile[sign_changes[c] + 1])
          x_val <- seq(x_interval[1], x_interval[2], length.out = 100)
          diff_interpol <- diff_function(x_interval, y_interval, x_val)
          sign_change <- which(diff(sign(diff_interpol)) != 0)
          boundary_lower <- x_val[sign_change]
          
          # Interpolate upper boundary 
          x_interval <- c(x_profile[sign_changes[c+1]], x_profile[sign_changes[c + 1] + 1])
          y_interval <- c(y_profile[sign_changes[c+1]], y_profile[sign_changes[c + 1] + 1])
          x_val <- seq(x_interval[1], x_interval[2], length.out = 100)
          diff_interpol <- diff_function(x_interval, y_interval, x_val)
          sign_change <- which(diff(sign(diff_interpol)) != 0)
          boundary_upper <- x_val[sign_change + 1]
          
          # Add region to data frame
          confidence_intervals_df <- rbind(confidence_intervals_df, data.frame(
            name = par_name,
            value = ci_na[j, "value"],
            lower = boundary_lower,
            upper = boundary_upper))
          
        # Region after last crossing point with interval [cn, ∞)
        } else if (c == length(crossing_points) && 
                   differences[sign_changes[length(sign_changes)]] > 0) {
          
          # Interpolate lower boundary 
          x_interval <- c(x_profile[sign_changes[c]], x_profile[sign_changes[c] + 1])
          y_interval <- c(y_profile[sign_changes[c]], y_profile[sign_changes[c] + 1])
          x_val <- seq(x_interval[1], x_interval[2], length.out = 100)
          diff_interpol <- diff_function(x_interval, y_interval, x_val)
          sign_change <- which(diff(sign(diff_interpol)) != 0)
          
          confidence_intervals_df <- rbind(confidence_intervals_df, data.frame(
            name = par_name,
            value = ci_na[j, "value"],
            lower = x_val[sign_change],
            upper = Inf))
        }
      }
    }
    
    # Data frame of CIs with original and adapted intervals
    ci_adapted <- ci[!(is.na(ci$lower) | is.na(ci$upper)),]
    ci_adapted <- rbind(ci_adapted, confidence_intervals_df)
  } else {
    ci_adapted <- ci
  }
  
  # Transform data frame with CIs into list
  par_names <- unique(ci_adapted$name)
  ci_list <- list()
  
  for (par_name_ci in par_names){
    ci_par <- subset(ci_adapted, name == par_name_ci)
    ci_list_par <- list()
    
    for (j in 1:nrow(ci_par)){
      ci_list_par <- c(ci_list_par, list(c(ci_par[j, "lower"], ci_par[j, "upper"])))
    }
    
    ci_list <- c(ci_list, list(ci_list_par))
    names(ci_list)[length(ci_list)] <- par_name_ci
  }
  
  return(ci_list)
}


################################################################################
# Function to compute the ECDF of a growth model

ecdf_func <- function(data) { 
  n <- length(data) 
  sorted <- sort(data) 
  
  ECDF <- rep(0, n) 
  for (j in 1:n) { 
    ECDF[j] <- sum(sorted <= data[j]) / n 
  } 
  return(ECDF) 
} 


################################################################################
# Function to classify pp-plot graph to one of the four classes

classification_pp_plot <- function(diff_emp_theo, tol, outlier){
  
  if (sum(diff_emp_theo < tol & diff_emp_theo > -tol) > (length(diff_emp_theo) - outlier)){
    out <- 1 # perfect consensus region
  } else if (sum(diff_emp_theo >= -tol) > (length(diff_emp_theo) - outlier)){
    out <- 2 # conservative region
  } else if (sum(diff_emp_theo <= tol) > (length(diff_emp_theo) - outlier)){
    out <- 3 # anti-conservative region
  } else {
    out <- 4 # alternating case
  }
  return(out)
}


################################################################################
##### Function to classify pp-plot for specific quantile #####

classification_pp_plot_thresh <- function(p, diff_emp_theo_cdf, theo_cdf, tol){
  
  min_idx <- which((theo_cdf - p)^2 == min((theo_cdf - p)^2))
  
  if ((diff_emp_theo_cdf[min_idx] < tol) & (diff_emp_theo_cdf[min_idx] > -tol)){
    out <- 1 # perfect consensus 
  } else if (diff_emp_theo_cdf[min_idx] >= tol) {
    out <- 2 # conservative 
  } else if (diff_emp_theo_cdf[min_idx] <= -tol) {
    out <- 3 # anti-conservative 
  } else {
    out <- NaN # error
  }
  return(out)
}